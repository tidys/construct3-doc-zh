{"./":{"url":"./","title":"说明","keywords":"","body":"说明 本教程时对Construct3官方文档进行汉化，翻译如果有不合适的地方，欢迎指正，谢谢！ "},"doc/beginner/":{"url":"doc/beginner/","title":"新手指南","keywords":"","body":"index "},"doc/beginner/beginner-guide.html":{"url":"doc/beginner/beginner-guide.html","title":"初学者教程","keywords":"","body":"本教程由 Construct3 团队推荐！ 这意味着它包含了有用的、高质量的信息，将帮助你成长为一个游戏开发者。 非常感谢选择Construct3！ 让我们开始制作你的第一个游戏吧。 我们将制作一个幽灵射击的演示游戏。 通过制作该游戏，您将彻底完全地学习一个游戏如何怎一步一步制作出来！ 其他平台教程 这个指南将制作一个从上往下射击的游戏，如果你想要其他平台的教程，可以尝试其他新手教程如何制作一个平台游戏 查看最终完成的游戏 了解我们的目标非常有必要，点击这里打开最终完成的游戏，加载完成后，点击Preview按钮（下面的红色圆圈箭头按钮）就可以运行游戏啦。 游戏规则为：使用鼠标控制玩家的方向，使用上下左右方向键移动玩家，点击鼠标左键发射子弹。 体验完毕之后，我们就可以正式开始接下来的教程了。 寻求帮助 如果你遇到任何困难、问题，都可以前往论坛。我们禁用了本教程的评论，因为这些评论可能很容易被大家忽略，在论坛里面，你会得到更多有用的回复。 开始 使用浏览器打开Construct3编辑器， 没错，是运行在浏览器中的！不需要其他任何的安装或者设置。如果打开后提示一些错误，请检查系统环境要求页面，您可能需要更新您的浏览器或者电脑系统。 创建一个新项目 点击New Project按钮 将会出现一个对话框，这里你可以对项目细节进行设置，我们先使用默认的设置，项目名字设置为Hello-C3 然后点击Create按钮，就会生成一个新的空项目，如图所示： 注意屏幕截图：我们在Construct3中使用了默认的主题，如果您改变了主题，可能和图示不太相同，不过不用担心，这完全不会有任何影响。 屏幕中间的主视图是布局视图（layout view），它是用来创建和摆放对象，可以简单的理解为游戏关卡或者屏幕菜单。在其他工具里面，可能被称为房间、场景、框架。 添加对象 让我们先添加一个游戏背景图吧。 平铺背景（Tiled Background） 每个游戏都有背景图，一般背景图都比较大，而且是规律性的重复，那么我们就需要在屏幕上重复平铺一张图片，而平铺背景对象就能满足需求。 首先，右键单击下边这张背景图，然后保存到你的电脑上。 现在，双击布局中的空白处，会打开对话框：创建一个新的对象，双击选择平铺背景对象（Tiled Background）。 鼠标将变为十字线，指示放置对象的位置。点击布局视图中间的某个地方，会打开新的对话框 你可以在该对话框绘制或者导入图片，这里，我们导入之前保存的背景图，单击文件夹图标，找到刚刚保存的背景图文件，并选择它。 导入完成后，我们点击对话框右上角的关闭按钮。现在布局中就能看到刚刚选择的背景图片。让我们试着调整下它的大小，使用鼠标选中背景图，然后我们会在左边的属性栏看到显示对象的所有属性。我们将它的位置设置为(0,0)左上角，大小设置为1708x960（默认的可视区域大小为854x480）。 让我们来整体浏览下我们刚才的工作内容。按住Ctrl键并向下滚动鼠标滚轮可以缩小，或者右键选择View→Zoom out来进行缩放，同样您还可以按住空格键或者鼠标中建来移动。 现在，您的平铺背景现在应该已经覆盖了整个布局视图： 按下Ctrl+0或者右键选择View→Reset zoom返回到1：1的视图。 （如果你像我一样没有耐心，可以直接点击工具栏上的预览按钮，然后弹出预览窗口，你就能看到平铺背景了） "},"doc/beginner/object.html":{"url":"doc/beginner/object.html","title":"添加对象","keywords":"","body":"在我们继续之前，平铺背景应该被锁定。如果我们在上边创建移动对象时，很容易因为误选而修改到其属性，这时我们可以锁定它，使它不可以被选择，这样就不会影响我们的操作了。要锁定它，右键单击平铺背景，并选择锁定选项即可。 添加输入对象 双击空白处（因为平铺背景已经锁定，所以可以双击任何地方）添加另外一个新的对象。这次我们选择鼠标对象Mouse Object，然后同样的操作，添加一个键盘对象KeyBoard Object。 需要注意的是，这些对象不需要放置在布局中，它们是隐藏的，并且自动在整个项目中工作。现在，我们的项目就可以接受鼠标和键盘的输入了。 游戏对象 是时候添加我们的游戏对象了，下面是游戏中的图像，同样的我们需要保存图片到电脑上 以上每个对象，我们都需要添加一个精灵对象Sprite Object，精灵负责显示图像，可以移动、旋转、调整大小和可选动画。一般游戏都是由精灵对象组成，让我们将上面的四张图片分别插入对应的精灵对象吧，这个过程和插入平铺背景非常像： 双击插入一个新对象 双击选择精灵Sprite 当鼠标变为十字线时，单击任何地方将其放置 弹出图像编辑器对话框，单击Load Image加载图像按钮，选择刚刚保存的图片 关闭图像编辑器对话框，现在已经可以在布局中看到精灵了 注意： 创建精灵对象的另一种快速方法是将图片文件拖拽到布局视图中，Construct3会自动创建一个带有该图像的精灵。 一定要一次拖动一个图片，如果你同时拖动所有的4个文件，Construct3将生成一个有四个动画帧的精灵。 我们需要移动子弹和爆炸精灵到布局的边缘，这样在游戏开始时，我们就看不到他们了。 为了方便识别对象，我们可以将刚才添加的4个精灵分别重命名为玩家、怪物、子弹、爆炸，选中对象，然后在属性（Properties）栏中修改Name属性即可： "},"doc/beginner/behaviors.html":{"url":"doc/beginner/behaviors.html","title":"添加行为","keywords":"","body":"添加behaviors(行为) behaviors(行为)可以使对象快速拥有某种行为表现。 比如你可以给对象添加一个Platform(平台)行为，接着给地板添加Solid(固体)行为，然后你就可以像一个平台跳跃游戏一样跳来跳去。 当然你也可以在event(事件)中实现同样的效果，但是行为更快速简单！ 在Construct3中有很多行为可供选择使用，以下是在本教程中使用到的部分行为： 8 Direction:你可以使用方向按键来自由移动一个物体，比如游戏中使用方向键控制玩家的移动。 Bullet: 物体会像玩家射击的子弹那样，沿着当前方向一直前进移动，当然你也可以用来移动游戏中的怪物，因为它们都是以一定的速度运动的。 Scroll To: 屏幕会始终跟随对象移动，如果你想让玩家始终显示在屏幕的中间，那么使用这个行为就再合适不过了。 Bound To Layout: 该行为将阻止对象离开指定的布局区域，就像一个盒子一样，玩家仅限在盒子的区域移动。 Destroy Outside Layout： 当物体离开布局区域时销毁它，比如我们希望子弹离开指定的区域后摧毁。如果没有他，那么子弹将飞出屏幕，而且不会销毁，这将会永远的占用部分内存，如果子弹比较多的话，可能对游戏性能也会产生影响。 Fade：使物体具有淡出效果，比如爆炸后的消失 了解了以上的行为后，让我们把他们添加到需要的对象上吧！ 如何添加行为 首先我们给玩家添加一个8 Direction行为。 点击选中玩家对象，在属性栏中会发现有Behaviors(行为)分类，点击Behaviors链接，编辑器将打开如图的行为对话框界面： 点击Add new behavior，双击8 Direction行为完成添加： 再次执行同样的操作，这次添加ScrollTo行为，使屏幕始终跟随玩家，然后再添加BoundToLayout行为，使玩家的活动范围仅限指定的区域。最终你的行为对话框应该如下图所示： 关闭行为对话框，现在我们尝试着按Preview来预览下游戏效果，你可以使用方向键来移动玩家，并且屏幕会跟随玩家的移动。并且因为BoundToLayout的原因，玩家不能移动到布局外。 这就是行为的方便之处，你可以为不同的对象快速添加相同的行为。 后续我们会使用事件系统来添加自定义的行为。 添加其他行为 我们可以通过相同的方法想其他对象添加行为：选中对象，然后单击行为链接，打开行为对话框，并添加一些行为。 让我们添加以下的行为吧： 为子弹对象添加Bullet和Destroy Outside Layout行为， 为怪物对象添加Bullet行为，因为游戏中怪物是慢慢移动前进的。 为爆炸对象添加Fade行为，因为爆炸在出现后悔慢慢消失。默认情况下，Fade行为会在行为结束后自动销毁对象，这样就能节省游戏的内存，保证游戏的流畅性。 如果你运行游戏后会发现子弹和怪物的移动速度一样快，让我们调慢一点怪物的移动速度。 选择怪物对象，注意，此时的属性栏因为已经添加了Bullet Movement行为，里面出现了一些额外的属性： 在这里我们就可以调整行为的具体参数，我们将Speed(速度)从400调整为80（以每秒移动的像素为单位）。 同样，我们改变子弹的速度为600，爆炸对象的Fade out time（淡出时间）为0.5s 生成更多的怪物 按住键盘的Control键，单击并拖动怪物对象，这时将会复制生成一个新的怪物对象实例。 我们使用Control+鼠标拖动，快速创建多个新的怪物吧，注意，怪物的位置尽量离玩家远一点，否则游戏可能刚开始，玩家就会马上死亡。你可以使用Control+鼠标滚轮来放大缩小布局，这样可以帮助你更加方便的调整细节。 最终的效果如图所示: 对象的本质是对象的类别。在事件系统中，主要处理的就是对象。 例如你可以创建一个事件，名字叫做子弹和怪物相撞，这意味着任何子弹对象的实例，和怪物对象的任何实例发生碰撞，而不是为每一个怪物对象制造一个单独的事件。 我们将在后续详细讨论这方面的内容，现在你可以理解为不同类型的敌人是不同的对象类型，而实际的敌人对象是这个敌人类型的一个实例。 接下来，我们就需要使用事件来添加我们自己的游戏逻辑，在事件系统中，Construct提供了可视化编程方案。 "},"doc/beginner/event.html":{"url":"doc/beginner/event.html","title":"添加事件","keywords":"","body":"事件 首先点击顶部的Event Sheet 1选项卡切换到事件表单预览，这里展示了所有的事件，在你的游戏中，不同的游戏对象可以拥有不同的事件表单。 事件列表里面还可以嵌套其他事件，这样你就能重复使用，本教程中暂时我们先不事件嵌套事件。 关于事件的说明 当你新建一个空事件表单时，Construct会有一些提示 大概意思是说，游戏的每一帧都会运行一遍事件表单里面的所有事件。 Construct会尽量最平滑的刷新游戏，通常游戏每秒刷新60帧，即事件表单每秒运行60次，每次刷新都会重新绘制游戏。 事件的执行顺序是从上到下，因此顶部的事件是最先运行的。 条件(conditions)，动作(actions)，子事件(sub-events) 事件由条件组成，当条件满足时就会触发事件。 例如条件是是否按下了空格键？，当按下空格键时，就会运行事件对应的所有动作(actions)。 在所有的动作执行完毕后，紧接着子事件(sub-events)就会执行，这些子事件也可以包含多个条件、动作，子事件。 事件系统可以让我们的游戏逻辑变得更加多样、复杂。 本教程中，我们暂且先不使用子事件。 总结一下，一个事件的运行流程大致如下： 图示是一个简单概括的流程，目前来说，你可以大致认为流程是这样的，当然Construct也提供了许多事件特性来满足你的不同需求。 你的第一个事件 我们希望玩家始终朝向鼠标的位置，如图所示，你需要如下设置： 请注意，游戏的每一帧画面都是重新绘制的画面，如果玩家每一帧都朝向鼠标的位置，那么游戏运行时，看起来就像玩家始终朝向鼠标。 让我们开始制作这个事件吧。双击事件表单中的空白区域，会弹出添加条件(condition)的对话框: 不同的对象允许拥有不同的条件和动作，条件和动作直接决定了对象的运行表现。 System是Construct的内置特性，我们双击System，如下所示，对话框会列出来所有的条件： 这里我们双击Every tick条件，也就是每一帧都会执行这个事件，这样就完成了事件的创建。 现在我们需要添加一个动作，让玩家看着鼠标。单击事件右侧的Add action链接 会打开如下对话框 和添加事件一样，需要选择一个对象，这里我们选择之前我们创建的游戏玩家对象，双击后会弹出添加行为对话框： 你可能注意到8 Direction也有了自己的动作，我们暂时先不关心这个问题，这里我们选择set angle toward position(设置朝向指定位置的角度)，这里我们没有使用set angle(设置玩家的朝向角度值)，因为这样满足不了我们的需求。 而set angle toward position会自动计算玩家位置和指定位置的角度。 我们这里选择如图所示的选项： 双击后会要求我们填写坐标，X、Y字段可以认为是该动作的参数，条件也是可以有参数的，只不过every tick条件是没有参数的。 现在我们想要设置设置角度朝向鼠标，而鼠标对象Mouse Object提供了这些功能。如下图所示: 输入的Mouse.x和Mouse.y被称为表达式，你还可以输入Mouse.x+100或者sin(Mouse.x)的计算表达式，通过这种方式，你可以使用任何数据来参与计算。 表达式使得Construct十分灵活强大。 注意：如果出现Mouse is not an object name，请确认你已经添加了Mouse Object 这里你可能会疑惑，难道我要记住所有的输入表达式么？ 不用担心，Construct在你输入时，会自动给出提示可用的输入列表来帮助你自动完成输入，并且会对象都拥有什么属性可供使用。 如果你不确定有哪些表达式可以输入，你可以点击Find Expressions查看所有的可用表达式列表，直接双击某个表达式，同样也会自动完成插入。 至此，就完成了你的第一个事件，最终如图所示: 运行游戏，你就会发现玩家会使用面对鼠标的位置，恭喜你完成了第一个自定义逻辑！ "},"doc/beginner/logic.html":{"url":"doc/beginner/logic.html","title":"添加游戏逻辑","keywords":"","body":"添加更多的游戏逻辑 如果每个事件都像之前那样详细的描述，那么本教程将会非常长。 让我们简单总结下之前是如何添加设置事件的： 双击或者单击Add action，插入一个新的事件。 双击对象设置条件(condition)/动作(action) 双击自己想要的条件(condition)/动作(action) 如果有参数，填写下参数 可以看到事件之后，紧跟的是条件(condition)/动作(action)，之后是所需要的参数。 那么，上篇教程中插入事件的流程可以这样描述： 添加条件：System->Every tick 添加动作：玩家->Set angle towards position，并且设置参数x:Mouse.X, y:Mouse.Y 让玩家开枪 一般，游戏中当玩家点击鼠标的时候，可以进行射击。 我们可以使用Spawn an object动作实现这个功能，该动作会在相同的位置和角度创建一个新的对象实例。 我们之前已经为子弹对象添加了一个Bullet，子弹会一直向前运行，现在我们需要再给子弹对象添加一些事件： 添加条件： Mouse->On Click->Left Clicked(默认) 添加动作：玩家->Spawn another object，选择子弹对象，使用默认参数即可。 操作完毕后，事件列表应该如下图所示： 此时如果你运行游戏，就可以射击子弹了。 但是你会发现子弹时从玩家的中间发射出来的，我们希望子弹时从枪口发射出来。 我们可以在枪口放一个图像点，图像点只是图像上的一个位置，方便我们从这个位置生成新的对象，我们在Spawn another object动作中引用这个位置即可。 在项目栏(project bar)中右击玩家对象，选择Edit animations(编辑动画): 在图像编辑面板中，单击图像点工具： 注意观察Image Points面板，里面列出了所有的图像点： 其中Origin是图像默认的原点，当物体进行旋转时，就会围绕Origin来旋转。 这里我们不使用Origin，右键新建一个图像点 然后将点设置到枪口，如下图所示 关闭图像编辑器，在event sheet中双击修改Spawn an object动作，并将图像点修改为1： 注意，这里的1表示第几个图像点，并不是图像点的名字。 再次预览游戏，子弹就从枪口中射出来了。虽然子弹现在还不能击杀怪物，不过，一旦你理解了事件系统，就可以很快的组织好你想要的逻辑。 下面，让我们的子弹杀死怪物吧，添加以下事件： 添加条件：子弹->On Collision with another object->怪物 添加动作：怪物-> Destroy 添加动作：子弹->Spawn another object->爆炸 添加动作：子弹->Destroy 最终完成效果如图所示： 预览游戏，射击一个怪物，你会发现爆炸有个黑色的边框！ 我们单击项目栏中的爆炸对象，修改Effect的混合模式为Additive(叠加)即可。 再次运行游戏，爆炸就正常了。 为什么会这样呢？一般情况下，图像时直接呈现到游戏中，但是在混合模式下，相同位置图片(也就是爆炸图片和背景图片)的每个像素都可以进行运算，黑色的颜色值为0，0和任何颜色值相加还是原颜色，所以，爆炸的黑框就消失了。 让怪物更聪明一点 现在这些怪物只是从布局边上移动到了右边，不够有趣，我们可以让怪物随机位置出现。 添加条件: System->on start of layout 添加动作：怪物->set angle，参数为random(360) 这样有一个问题，当怪物离开布局的时候，就永远离开了，再也回不来了，不过我们可以让它始终呆在布局里面。 我们还可以置当怪物离开布局的时候，让它们自动冲向玩家，这样就能保证怪物始终在布局内，如果玩家一直站着不动，那么怪物最终会冲向玩家！ 添加条件: 怪物->is outside layout 添加动作：怪物->set angle toward position X:玩家.X Y:玩家.Y 最终的完成样子如下图： 运行游戏，你如果停留一段时间，你就会发现怪物会停留在布局的边缘，并且它们随机朝向一个方向。 现在点击鼠标左键，就会射击子弹，如果子弹碰到怪物就会立刻击杀怪物，如果我希望怪物被子弹击中5次才会死亡，那么该怎么做呢？我们可以使用变量来做到！ "},"doc/beginner/variables.html":{"url":"doc/beginner/variables.html","title":"使用变量","keywords":"","body":"使用变量 变量可以使每个怪物都有自己的生命值。变量的本质是一个可以变化的值，它们时存储在每个对象的具体实例中。 让我们给怪物添加生命值变量，操作和之前的添加事件非常相似。 单击选中一个怪物对象，会在属性栏中看到其具体的属性，点击instance variables(实例变量)打开变量对话框。 你可以添加任意多个变量，这里我们只需要添加一个变量。点击Add new instance variable创建变量。 名字(name)我们输入生命值，类型(type)设置为Number，初始值(initial value)设置为5，这样，每个怪物就拥有了5点生命值。 当怪物被击中时，我们减去一点生命值，当生命值为0时，怪物就死亡销毁掉。 点击ok，完成变量的创建，所有的怪物都会拥有生命值的变量，数据彼此之间是相互独立的，并且可以单独设置每个怪物的生命值都不同，点击不同的怪物，可以在属性栏中可以快速修改初始值。 如果要添加、删除变量，就需要打开实例变量对话框进行操作。 改变事件 现在，我们想要子弹击中怪物后，生命值减少1。 切换到事件表中，找到子弹:on collision with 怪物的事件，之前我们是添加了一个摧毁怪物的动作，现在我们替换成生命值减1，如图所示，点击替换(replace action)的操作： 同样的操作，我们选择: 怪物->subtract from->生命值->value：1： 最终替换后如下图所示： 现在，当我们射击怪物时，它们就会减少1点生命值，但是子弹也会爆炸。 我们需要再添加另外一个事件： 添加条件： 怪物->Compare instance variable->生命值 添加动作：怪物-> Spawn another Object->爆炸 添加动作：怪物->Destroy 为什么是呢？如果我们增加了一个威力更强大的武器，每次减少2生命值，当你击杀一个怪物的时候，怪物的生命值可能不会等于0，所以怪物永远不会死！ 现在运行游戏，怪物需要击中5发子弹才能杀死了！ "},"doc/beginner/keeping-score.html":{"url":"doc/beginner/keeping-score.html","title":"记录分数","keywords":"","body":"记录分数 当玩家每杀死一个怪物，我们就记1分，所以我们需要有一个分数的变量，但是在Construct里，变量都是存储在对象里面的，如果我们把分数变量放在玩家对象里面，当玩家对象死亡销毁时，就无法得知分数了。 因此，我们不能将分数变量放在玩家对象上，我们可以使用全局变量。 右击事件底部的空白部分，选择add global variable 名字我们输入分数，初始化设置为0，其他字段默认即可。 创建完成后，全局变量在事件中显示为一行，在这个事件表单中，任何事件都可以访问这个变量 让我们再修改下事件，当怪物的生命值 添加动作：System->Add to->生命值，value:1 最终事件如下图所示： 现在，每次杀死一个怪物，分数就会+1，但是这个分数并没有在游戏中显示，下一节我们会用一个文本来展示这个分数。 "},"doc/beginner/display-score.html":{"url":"doc/beginner/display-score.html","title":"显示分数","keywords":"","body":"展示分数 文本对象可以显示分数。一般分数都是出现在屏幕的固定位置，而当前的游戏视图，默认是跟随玩家的，我们不希望玩家的移动，影响分数的显示位置，所以，我们需要新添加一个图层。 增加一个图层 布局可以包含多个图层，这样你就可以为对象分组。你可以想象为一层又一层的玻璃，叠加在一起，每一层上都有不同的画面。图层可以自由的调整层级关系，实现前后遮挡的效果，也可以隐藏，锁定等等。 这里我们把分数放在一个新的图层，并且这个图层在顶层。 下图是图层栏，在默认的面板布局中，它是在屏幕的右下角： 右键单击图层，选择add layer at top创建新图层，新图层名字叫做分数 Parallax属性 默认情况下，图层时跟随着视图的移动而移动，而图层的Parallax(视差)属性可以调整移动效果，允许不同的图层以不同的速度滚动，产生一种伪3D的效果。 这里我们不希望分数图层移动，分数图层应该始终在屏幕的固定位置，所以设置Parallax(视差)为0即可。 注意，在设置图层属性的时候，请务必确认选中正确的图层。 添加文本对象 我们切换到布局视图，确保当前是分数图层。 双击空白区域，这次我们添加Text对象 将text对象放在布局的左上角，然后调整属性，设置为粗体，斜体，黄色，并选择一个稍微大点的字体。 调整宽度，保证所有文本都能显示。 切换到事件表中，我们需要及时更新玩家的分数，在前面添加的Every tick事件中，对分数对象添加set Text。 使用&，我们可以将一个数字转换为文本，并将其连接到另一个文本字符串。因此，我们可以这样输入\"分数：\"&分数 第一部分的\"分数：\"是自定义的字符串，注意，字符串必须用双引号 第二部分是全局变量分数的实际值。 最终事件修改如下图所示： 运行游戏，每次击杀一个怪物，你的分数就会及时刷新，并且分数始终在屏幕的固定位置。 "},"doc/beginner/finish.html":{"url":"doc/beginner/finish.html","title":"完成","keywords":"","body":"最后的优化 运行游戏后，你会发现一旦杀死了所有的怪物，就不会再有任何怪物了，我们可以每3秒创建一个新的怪物。 添加一个新的事件： 添加条件: System->Every X seconds->3 添加动作：System->Create Object->怪物，layer0，x:layoutWidth+100, y:random(LayoutHeight) 注意，这里我们创建的怪物，默认位置是在布局的最右边随机位置，为了保证不会突然出现在边缘，所以+100，这样看起来就像真的从外面进来。 我们还可以实现，如果玩家碰到了怪物就会死去 添加条件：怪物->on collision with another object->玩家 添加动作: 玩家->Destroy 到此为止，本教程就完结了，如果你要预览完整的游戏，可以点击这里，或者在开始页搜索Ghost Shooter(幽灵射手)。 更多可以尝试的想法 以下提供了游戏的额外玩法，可以尝试着实现： 玩家击中怪物也可以获得分数，当然杀死怪物分数更高。并且每个怪物的分值也是不同的。 怪物随着时间的加速，移动速度会越来越快。 增加新类型的敌人。 添加心得武器，玩家可以进行切换。 增加一些游戏声音，比如怪物死亡声音，子弹射击声音等。 增加游戏开始，游戏结束等界面。 增加一些障碍物。 结尾 恭喜你已经完成了在Construct3制作的第一个游戏，如果你想要分享给别人，可以导出 发布到你想要分享的平台上 接下来如何深入学习 可以看下这个教程：入门教程：如何学习Construct3，这篇教程将由浅入深，让你深入了解Construct3 查阅Construct3的使用手册 浏览起始页的示例，里面包含了所有的Construct3特性 论坛交流 "},"doc/document/":{"url":"doc/document/","title":"官方完整手册","keywords":"","body":"index "},"doc/document/Home.html":{"url":"doc/document/Home.html","title":"主页","keywords":"","body":"home "},"doc/document/behaviors-reference.html":{"url":"doc/document/behaviors-reference.html","title":"行为参考","keywords":"","body":"behaviors-reference "},"doc/document/plugin.html":{"url":"doc/document/plugin.html","title":"插件","keywords":"","body":"plugin "},"doc/plugin/":{"url":"doc/plugin/","title":"插件","keywords":"","body":"index "},"doc/plugin/home.html":{"url":"doc/plugin/home.html","title":"主页","keywords":"","body":"欢迎来到Construct3 JavaScript SDK文档。 JavaScript SDK允许开发者开发自己的Construct3插件，在插件里面，你可以创建自定义的behaviors、effects，甚至你可以修改编辑器的外观主题。 请注意，目前并非所有的SDK特性都有效，该文档后续可能随着新功能的推出同步更新 下载SDK 最后更新时间:2020年9月2日 插件SDK Behavior SDK Effect SDK Editor Theme SDK 如果你想在Construct3编辑器中测试以上插件，你可以将插件的zip文件直接重命名为.c3addon，然后通过编辑器的插件管理加载插件。 在开发插件的时候，在本地HTTP服务器上使用开发模式，可以提高开发效率 自定义导入器API 这个插件包含了一个使用自定义导入器的例子 你可以直接将这个插件拖放到Construct3中，就能看到插件是如何读取自定义格式的。 你需要掌握web技能 插件是使用JavaScript编写，另外需要你掌握web技能(Html、Css)。 不过本文档不会去教你这些，需要你自己从网上搜索一些资料进行学历。 "},"doc/plugin/guide/c3addon.html":{"url":"doc/plugin/guide/c3addon.html","title":"插件结构","keywords":"","body":"Construct3插件的扩展名是.c3addon，本质上和zip没有任何区别，所以你可以像查看压缩文件一样查看插件的内容。 插件结构 c2runtime：construct2的运行时文件，通常只包含runtime.js。 c3runtime: construct3的运行时文件。 lang en-US.json ：语言文件，包含显示在编辑器界面的字段。 aces.json：定义一些actions(行为)、conditions(条件)、expressions(表达式) addon.json： 定义一些插件的信息，详细字段参考插件信息 icon.svg：插件的图标，这里使用的是svg plugin.js：声明插件的类，详细字段参考 types.js：编辑器中使用到的的类型 instance.js：编辑器中使用的插件实例 behavior.js：定义插件的行为信息 "},"doc/plugin/guide/addon.json.html":{"url":"doc/plugin/guide/addon.json.html","title":"addon.json","keywords":"","body":"addon.json中定义了详细的插件信息 is-c3-addon：true/false 布尔值：用于识别是否为Construct3的插件 type：\"plugin\"/\"behavior\"/\"effect\"/\"theme\" 插件的类型： name: 插件名字 id：插件的唯一标识 version：插件版本号 author：插件作者 website：插件的介绍网站 documentation：插件的在线帮助文档 description：插件描述，用户在安装插件时，会看到该信息。 editor-scripts：编辑器要加载的文件，当type为plugin、behavior有效 推荐使用默认的配置，如果你想把插件合并压缩到一个脚本中，或者你依赖了第三方脚本，你需要修改这个字段。 stylesheets：编辑器使用的样式，当type为theme时有效 file-list：插件使用到的所有脚本，在开发者模式下有效 { \"is-c3-addon\": true, \"type\": \"plugin\", \"name\": \"My custom plugin\", \"id\": \"MyCompany_MyAddon\", \"version\": \"1.0.0.0\", \"author\": \"Scirra\", \"website\": \"https://www.construct.net\", \"documentation\": \"https://www.construct.net\", \"description\": \"Example custom Construct 3 plugin.\", \"editor-scripts\": [ \"plugin.js\", \"type.js\", \"instance.js\" ], \"file-list\": [ \"c2runtime/runtime.js\", \"lang/en-US.json\", \"aces.json\", \"addon.json\", \"icon.svg\", \"instance.js\", \"plugin.js\", \"type.js\" ] } effect类型插件的配置 当你在开发type为effect类型的插件时，addon.json中有关的字段配置，参考这里 新添加的插件可以在这里看到 "},"doc/plugin/guide/addon.effect.html":{"url":"doc/plugin/guide/addon.effect.html","title":"effect","keywords":"","body":"当插件类型为effect时，addon.json中会使用到如下配置， 也就是我们常说的shader category：分类 可选值为 blend color distortion normal-mapping other blends-background：true/false 指示效果是否于背景混合 cross-sampling：true/false 交叉采样 preserves-opaqueness：true/false animated: true/false effect是否是动画的 must-predraw：true/false 是否强制预绘步骤 extend-box \"extend-box\": { \"horizontal\": 30, \"vertical\": 30 } is-deprecated :true/false 是否废弃 parameters：参数 "},"doc/plugin/guide/plugin.js.html":{"url":"doc/plugin/guide/plugin.js.html","title":"plugin.js","keywords":"","body":"定义插件的对象 示例代码： const PLUGIN_ID = \"MyCompany_MyAddon\"; const PLUGIN_VERSION = \"1.0.0.0\"; const PLUGIN_CATEGORY = \"general\"; class MyCustomPlugin extends SDK.IPluginBase { constructor () { super(PLUGIN_ID); this._info.setName(\"hello plugin\"); this._info.SetProperties([ new SDK.PluginProperty(\"integer\", \"test-property\", 0) ]); } } SDK.Plugins.MyCompany_MyAddon = MyCustomPlugin; const PLUGIN_CLASS = MyCustomPlugin; 在type.js、 instance.js中，我们会使用SDK.Plugins的MyCompany_MyAddon属性来获取插件实例， 所以，如果这里发生了变化，记得同步更新 常量 PLUGIN_ID 插件的唯一标识，必须和addon.json中的值相同，请尽量避免反复修改 PLUGIN_VERSION 插件版本号，必须和addon.json中的值相同 PLUGIN_CATEGORY 插件的类别，当创建一个新的对象类型时，会显示 可选的值为： value desc data-and-storage - form-controls - general - input - media - monetisation - platform-specific - web - other - 插件的主类 在构造函数中，插件的配置是通过this._info设置的，这是一个IPluginInfo的接口 通过this._info.SetProperties接口，我们可以为对象示例新增自定义属性。 当选中插件实例时，插件属性会出现在属性栏，具体编辑器中属性显示的文本，是从lang语言文件中读取出来的。 同时会看到这个对象来自插件MyDrawing "},"doc/plugin/guide/behavior.js.html":{"url":"doc/plugin/guide/behavior.js.html","title":"behavior.js","keywords":"","body":"behavior.js主要配置行为 常量 const BEHAVIOR_ID = \"MyCompany_MyAddon\"; const BEHAVIOR_VERSION = \"1.0.0.0\"; const BEHAVIOR_CATEGORY = \"general\"; BEHAVIOR_ID 必须和addon.json中ID的值相同 BEHAVIOR_VERSION 必须和addon.json中version的值相同 BEHAVIOR_CATEGORY 当在对话框中添加behavior，展示的行为类别， 可选值为： attributes general movements other class MyCustomBehavior extends SDK.IBehaviorBase { constructor () { super(); } } const BEHAVIOR_CLASS = MyCustomBehavior; SDK.Behaviors.MyCompany_MyAddon = MyCustomBehavior; 在构造函数中，插件的配置是通过this._info设置的，这是一个IPluginInfo的接口 当选中行为实例时，行为属性会出现在属性栏，你需要这样设置属性： this._info.SetProperties([ new SDK.PluginProperty(\"integer\", \"test-property\", 0) ]); "},"doc/plugin/guide/aces.json.html":{"url":"doc/plugin/guide/aces.json.html","title":"aces.json","keywords":"","body":"actions、conditions、expressions简称ACE，用来指一个动作、条件、表达式。 { 'ace1': { 'conditions': [], 'actions': [], 'expressions': [] } } 每个key都是类别ID，在编辑器中显示的字符，会从语言文件中查找 ACE中的每条数据都是一个json { \"id\": \"every-tick\", \"scriptName\": \"EveryTick\" } ACE最小数据 参数 conditions actions expressions id √ √ √ scriptName √ √ - expressionName - - √ returnType - - √ id c2id：construct2升级上来的 scriptName / expressionName ：ACE运行时脚本中的函数名 isDeprecated： true/false 是否废弃 highlight：设置为 true 以突出显示条件/操作/表达式选择器对话框中的 ACE。这应该只用于最常用的 ace，以帮助用户从列表中轻松地挑出它们 params: 参数 Condition特有的属性 isTrigger：指定触发器条件。这将在事件表中显示箭头。触发器只有在它们是由运行时调用触发的明确时才运行，而不是计算每个滴答 isFakeTrigger：指定一个假的触发器。这看起来与事件表中的触发器完全相同，但实际上是每隔计算一次。这对于对于单一刻度为真的条件非常有用，例如对于必须每刻度轮询一个值的 api isStatic： 通常，条件运行时方法对每个选定的实例执行一次。如果条件被标记为 static，则运行时方法只在对象类型类上执行一次。这意味着运行时方法还必须完全自己实现实例选择，包括考虑否定和 OR 块 isLooping： 在事件表中显示一个图标，以指示条件循环。这应该只用于实现重新触发的条件 isInvertible：允许条件在事件表中被反转。设置为false关闭逆变装置 isCompatibleWithTriggers： Action特有属性 isAsync：将 action 标记为异步操作 Expression特有属性 expressionName returnType：\"number\", \"string\", \"any\" isVariadicParameters ：是否允许用户输入任意数量的参数 Params参数 { \"id\": \"compare-two-values\", \"scriptName\": \"Compare\", \"params\": [ { \"id\": \"first-value\", \"type\": \"any\" }, { \"id\": \"comparison\", \"type\": \"cmp\" }, { \"id\": \"second-value\", \"type\": \"any\" } ] } expressions 只能使用 \"number\", \"string\" or \"any\"参数类型. id c2id: type: number string any boolean：布尔值，显示一个复选框 combo:下拉列表，必须指定item属性 cmp：下拉列表，包含大于，小于，等于 object：对象选择器，allowedPluginIds定义了筛选的对象 objectname：字符串，对象名字 layer：字符串，层名字 layout：一个包含项目中所有布局的下拉列表 keyb：按键拾取器 instancevar：包含对象具有的非布尔实例变量的下拉列表 instancevarbool：包含对象具有的布尔实例变量的下拉列表 eventvar：作用域中包含非布尔事件变量的下拉列表 eventvarbool：作用域中包含布尔事件变量的下拉列表 animation：对象中的动画名称 objinstancevar： initialValue：初始值 items： 下拉数据数组，combo有效 allowedPluginIds： 设置为对象选择器允许显示的插件 id 数组[\"Sprite\"] ACES主要在事件表中使用 点击添加事件，从对象列表中添加事件的对象 为对象添加条件，这里就出现了插件中的is-large-number条件 接着为设置条件的参数 设置完毕后，就会在事件表中出现一条新增的事件 接着为为这个事件添加actions 添加actions也需要指定执行actions的对象 这里我们仍旧选择插件的实例对象，当然你也可以选择其他对象 这里就出现了自定义的do alert，选择后，该事件如下所示 图中我们可以推导出大概的事件机制： "},"doc/plugin/guide/develop-mode.html":{"url":"doc/plugin/guide/develop-mode.html","title":"插件开发调试","keywords":"","body":"调试插件 1.启用开发者模式 打开设置对话框，点击标题栏10次 就会在设置中出现开发者模式 2.启动本地服务 你只需要将你的插件放在本地服务下，保证localhost:8080/addon.json能够被正常加载即可 3. 更新插件的file-list 4.安装插件 打开编辑器插件管理：菜单->视图->插件管理 当启用开发者模式后，会出现添加开发插件按钮，点击后，在对话框填写url即可(注意：填写localhost即可，ip可能会遇到各种问题) 安装成功之后，需要重启下编辑器，然后你会在console中看到这个插件被正确加载了 5.更新插件 如果插件代码更新了，修完完毕之后，你需要重新刷新下编辑器即可 插件示例工程 开发插件的DEMO "}}